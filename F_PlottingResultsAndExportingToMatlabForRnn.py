# -*- coding: utf-8 -*-
__author__ = 'Hossein Mehri'
__license__ = 'MIT'
"""
Created on Wed Jun 14 23:17:26 2023

@author: Hossein Mehri

This code loads the evaluation results from previous codes and presents them.
Moreover, The results are saved in ".mat" format to be used by MATLAB in case 
of plotting high quality plots for presentation.

This code executes the sixth of six steps in predicting the mMTC network's traffic
using the Fast LiveStream Predictor (FLSP) algorithm, a new live forecasting algorithm.

 --------------------------      ---------------      ------------------------------------
|GeneratingTrafficPatterns| --> |RnnNetTraining| --> |GeneratingBurstDetNetFeedDataForRNN| -->
--------------------------      ---------------      ------------------------------------
     -------------------------------      ---------------------------------------------
--> |BurstDetNetTrainingWithRNNData| --> |EvaluatingNetworksAndGeneratingResultsForRNN| -->
    -------------------------------      ---------------------------------------------
     vvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvv
--> |PlottingResultsAndExportingToMatlabForRNN|
    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

The code loads required data from "A_generatedTraffic", "B_trainedRNN",
"C_burstFeedDataForRnn", "D_trainedBurstNetForRnn", and "E_EvaluationResultsForRnn"
folders. The files are stored in "F_MatlabFiles".

You can modify the following parameters:
    - loadPlotSeq: Boolean variable indicating that if you want to load prediocted
                   sequences or generate them here;
    - saveResults: If you want a copy of results for plotting in MATLAB;
    - focusArea: Limiting the simulations for faster results;
    - limitPlotRange: A limitation on plottign range to get a clear plots.
    
"""

import torch
from torch import nn
import copy
import numpy as np
from scipy import signal
from tqdm import tqdm
import matplotlib.pyplot as plt 
from MLNetworks import dataManagement, countParameters
from MLNetworks import  textColorFormat as TC
from B_RnnNetTraining import preprocess

if __name__=='__main__':
    loadPlotSeq=True # Load the generated predictions for random sequences from "F_" codes.
    saveResults=False # If you want to store the results of the simulation.
    ## Loading the required data:
    testResults_E=dataManagement(choice=True, path='E_EvaluationResultsForRnn') # Loading evaluation results.
    allLoadedAddress=testResults_E.get('allLoadedAddress') # Address of all used in generating results.
    if loadPlotSeq:
        seqForPlotting=testResults_E.get('seqForPlotting') # Chosen sequences for plotting.
        focusArea=np.array([0,180000]) # Whole the sequence is used for plotting
    else:
        seqForPlotting=np.random.choice(range(400, 500),2,replace=False)
        focusArea=np.array([0,180000]) # For faster results, this can be modified.
    limitPlotRange=32000 # Besides focus Area, this one puts another limitation on plot ranges for clear results.
    patternData_A=dataManagement(address=allLoadedAddress['patternDataAddress']) # Loading traffic patterns.
    trainedRnnNet_B=dataManagement(address=allLoadedAddress['addressLoadRNN'])
    origData_C=dataManagement(address=allLoadedAddress['origDataAddress']) # Labels and Presentation sequences.
    RNNData_C=dataManagement(address=allLoadedAddress['rnnDataAddress']) # RNN data: generated by a trained RNN network.
    burstNetData_D=dataManagement(address=allLoadedAddress['burstNetAddress'],map_location='cpu') # Trained burst prediction network.
    ## Extracting the required information from the loaded data.
    patternArray=np.array(patternData_A.get('Pattern'))[:,[0,2],:] # Only traffic and congestion sequences 
    patternArray=signal.savgol_filter(patternArray,97,2) # Making data smooth.
    rnnTrainingLossHistory=trainedRnnNet_B.get('losshist') # Loss history of RNN network training.
    rnnValidationLossHistory=trainedRnnNet_B.get('valLoss') # Validation loss history of RNN network.
    description_B=trainedRnnNet_B.get('Description') # Simulation description of RNN network training.
    burstLabels=origData_C.get('burstLabels') # Labels of bursty area.
    exactCongAreaData=origData_C.get('exactCongAreaData') # A sequence showing the exact location of congested area.
    description_C=origData_C.get('description_C')
    burstPredictionNetworks=burstNetData_D.get('burstPredictionNetworks') # Burst prediction networks.
    burstPredTrainingAccuracyMetrics=burstNetData_D.get('trainingAccuracyMetrics') # The history of accuracy metrics of burst prediction network.
    burstPredValidationAccuracyMetrics=burstNetData_D.get('validationAccuracyMetrics') # The history of accuracy metrics of validation of burst prediction network when using original data bunches as feed data.
    burstPredRnnTrainAccuracyMetrics=burstNetData_D.get('rnnTrainAccuracyMetrics') # The history of accuracy metrics of burst prediction network when using RNN output bunches as feed data.
    burstPredRnnValAccuracyMetrics=burstNetData_D.get('rnnValAccuracyMetrics') # The history of accuracy metrics of validation of burst prediction network when using RNN output bunches as feed data.
    burstPredValidationLossRNN=burstNetData_D.get('validationLossRNN') # The loss history of validation of burst prediction network when using RNN output bunches as feed data.
    rnnTestTraffPredLoss=testResults_E.get('traffPredLoss') # Traffic prediction loss in testing phase of RNN network.
    burstPredTestLoss=testResults_E.get('burstDetLoss') # Burst prediction loss in testing phase of burst predictio network.
    burstPredTestAccuracyMetrics=testResults_E.get('accuracyMetrics') # Accuracy metrics of burst predictio network in testing phase using FLSP outputs.
    burstPredTestAccuracyMetricsRoll=testResults_E.get('accuracyMetricsRoll') # Accuracy metrics of burst predictio network in testing phase using Rolling outputs.
    description_E=testResults_E.get('Description') # Simulation description of testing phase.
    batchSize=testResults_E.get('batchSize') # Batch size.
    TpVec=testResults_E.get('TpVec') # List of prediction duration at each step.
    TpVec_B=trainedRnnNet_B.get('TpVec') # Temporary! Should be solved in ..._B file.
    Tseed=testResults_E.get('Tseed') # Seed data duration used to initialize the RNN network.
    Tstep=testResults_E.get('Tstep') # Frequency of collecting new data as well as fresh data duration.
    frameSize=0.005
    totalNumberOfPatterns=patternArray.shape[0]
    #%% Printing the simulation descriptions:
    print('Simulation description of file "B"\n',description_B)
    print('Simulation description of file "C"\n',description_C)
    print('Simulation description of file "E"\n',description_E)
    print(TC('The number of parameters of the RNN model: '+\
          f'{countParameters(list(trainedRnnNet_B["model"].parameters())):,}','y00'))
    #%% Plotting the training loss for RNN network and training metrics for burst prediction networks:
    figLoss=plt.figure(figsize=[9,9])
    plt.subplot(3,1,1)
    epochs=np.linspace(1,len(rnnTrainingLossHistory),len(rnnTrainingLossHistory)) # The x-axis vector
    plt.plot(epochs,rnnTrainingLossHistory,linewidth=3,label='RNN Training MSE Loss')
    plt.plot(epochs[-1],rnnTrainingLossHistory[-1],'rx',ms=10)
    props = dict(boxstyle='round', facecolor='wheat', alpha=0.5)
    yText=rnnTrainingLossHistory[-1]*20
    if yText>max(rnnTrainingLossHistory):
        yText=0.7*max(rnnTrainingLossHistory)
    plt.text(epochs[-1]*0.78,yText,'Final loss value: {:0.3f}'.\
          format(rnnTrainingLossHistory[-1]),color='red',bbox=props)
    plt.legend()
    plt.ylabel('Loss value')
    plt.xlabel('Epoch number')
    plt.grid()
    plt.title('Training Loss of Traffic Prediction (RNN) Network')
    plt.subplot(3,1,2)
    iTp=1 # Selected Tp to plot metrics:
    burstTrainingLoss=burstNetData_D.get('lossHist')
    trainEpochs=len(burstPredTrainingAccuracyMetrics[iTp][0]) # Due to extra training epochs, it may vary for different Tps.
    epochs=np.linspace(1,trainEpochs, trainEpochs) # The x-axis vector
    plt.plot(epochs,burstTrainingLoss[iTp][:trainEpochs],'C4',linewidth=3,\
              label=' Burst Det. Training MSE Loss')
    plt.plot(epochs[-1],burstTrainingLoss[iTp][:trainEpochs][-1],'rx',ms=10)
    yText=burstTrainingLoss[iTp][:trainEpochs][-1]*20
    if yText>max(burstTrainingLoss[iTp][:trainEpochs]):
        yText=0.7*max(burstTrainingLoss[iTp][:trainEpochs])
    plt.text(epochs[-1]*0.78,yText,'Final loss value: {:0.3f}'.\
          format(burstTrainingLoss[iTp][:trainEpochs][-1]),color='red',bbox=props)
    plt.legend()
    plt.ylabel('Loss value')
    plt.xlabel('Epoch number')
    plt.title(f'Training Loss of Burst Detection Network for TP={TpVec[iTp]}')
    plt.grid()
    plt.subplot(3,1,3)
    plt.title(f'Training Accuracy Metrics of Burst Prediction Net. for Tp={TpVec[iTp]}')
    plt.plot(epochs,np.array(burstPredTrainingAccuracyMetrics[iTp][0]),linewidth=3,label='Precision')
    plt.plot(epochs,np.array(burstPredTrainingAccuracyMetrics[iTp][1]),linewidth=3,label='Recall')
    plt.plot(epochs,np.array(burstPredTrainingAccuracyMetrics[iTp][2]),linewidth=3,label='F1-Score')
    plt.plot(epochs[-1],burstPredTrainingAccuracyMetrics[iTp][2][-1],'rx',ms=10)
    yText=burstPredTrainingAccuracyMetrics[iTp][2][-1]*0.8
    plt.text(epochs[-1]*0.8,yText,'Final F1-Score: {:0.3f}'.\
          format(burstPredTrainingAccuracyMetrics[iTp][2][-1]),color='red',bbox=props)
    plt.legend()
    plt.ylabel('Metric value')
    plt.xlabel('Epoch number')
    plt.grid()
    figLoss.set_tight_layout('tight') # Solving overlapping labels.
    plt.show()
    #%% Preparing the exemplary sequences for plotting burst detection network results:
    TstepSamples=int(Tstep/frameSize) # Number of samples at each step
    # We should ignore the seed data and corresponding labels:
    afterSeedLabelPointer=int(int(Tseed/frameSize/batchSize)/int(Tstep/frameSize/batchSize))
    traffPattern=patternArray[seqForPlotting[1],0,afterSeedLabelPointer*TstepSamples:] # The selected traffic pattern to plot the results.
    congPreambles=patternArray[seqForPlotting[1],1,afterSeedLabelPointer*TstepSamples:] # The selected congestion pattern to plot the results.
    exactCongArea=dict([(f'Sequence {chosenStream}',exactCongAreaData[0][chosenStream]\
                         [afterSeedLabelPointer*TstepSamples:]) for chosenStream\
                        in seqForPlotting]) # We have several versions for each Tp, but they are the same.
    expectedBurstyAreas=dict([(f'Sequence {chosenStream}',dict()) for chosenStream \
                             in seqForPlotting])
    for chosenStream in seqForPlotting:
        for iTp,Tp in enumerate(TpVec):
            expectedBurstyAreas[f'Sequence {chosenStream}'][f'Tp={Tp}']=\
                torch.from_numpy(burstLabels[iTp][chosenStream][afterSeedLabelPointer:])\
                .repeat_interleave(TstepSamples).numpy()
    # Determine the x-axis time array:
    a=afterSeedLabelPointer*TstepSamples*frameSize # Time of first point after the seed data.
    b=patternArray[seqForPlotting[1],0].shape[0]*frameSize # Time of the last point of data.
    length=congPreambles.shape[0] # Total numnber of samples in the sequences to be plotted.
    xAxis=np.linspace(a,b,length)
    # Generating the burst predictions for a random sequence:
    burstNetOut=dict([(f'Sequence {chosenStream}',dict()) for chosenStream \
                             in seqForPlotting])
    # First Sequence:
    feed=RNNData_C.get('linearNetInputs')[seqForPlotting[0]] # Load the predicted bunches of the selected sequence by RNN network to feed to burst prediction network.
    output=dict([(Tp,[]) for Tp in TpVec]) # A dictionary to save the ouput results.
    with torch.no_grad():
        for iTp,Tp in enumerate(TpVec): # Predicting the bursty congested areas.
            output[Tp]=((burstPredictionNetworks[iTp](feed)).reshape(-1)>0.5)*1
            burstNetOut[f'Sequence {seqForPlotting[0]}'][f'Tp={Tp}']=\
                output[Tp].repeat_interleave(TstepSamples).numpy()
    # Second Sequence:
    feed=RNNData_C.get('linearNetInputs')[seqForPlotting[1]] # Load the predicted bunches of the selected sequence by RNN network to feed to burst prediction network.
    output=dict([(Tp,[]) for Tp in TpVec]) # A dictionary to save the ouput results.
    with torch.no_grad():
        for iTp,Tp in enumerate(TpVec): # Predicting the bursty congested areas.
            output[Tp]=((burstPredictionNetworks[iTp](feed)).reshape(-1)>0.5)*1
            burstNetOut[f'Sequence {seqForPlotting[1]}'][f'Tp={Tp}']=\
                output[Tp].repeat_interleave(TstepSamples).numpy()
            
    #%% Plotting an exemplery sequence of data showing relation between labels and...\
    # traffic sequences (arrivals, successfully detected, congestions):
    Tp=2 # Plotting for Tp=2
    predBurstSeq=burstNetOut[f'Sequence {seqForPlotting[1]}'][f'Tp={Tp}'] # Getting congestion labels as a hint to a test congested area
    arrivals=signal.savgol_filter(patternData_A.get('Intensity')[seqForPlotting[1]][0],97,2) # Arrival data for the chosen sequence
    offset=int(RNNData_C.get('Tseed')/0.005) # An offset due to seed data. We use it to choose the correct range for arrival sequence.
    criticalPoints=np.nonzero(predBurstSeq)[0] # Points that we expect bursty traffic.
    range11=[criticalPoints[0]-1000] # Store the starting point of first bursty traffic  (plus an extension).
    range22=[criticalPoints[0]+2000] # Store the end point of first bursty traffic (plus an extension).
    for criticalPoint in criticalPoints:
        if criticalPoint>(range11[-1]+2000): # Extracting the start and end point of a bursty area
            range11.append(criticalPoint-1000) # Start point of bursty traffic
            range22.append(criticalPoint+2000) # End point of a bursty traffic
    rows=int(np.ceil(len(range11)/2)) # Required rows to plot all of them in one figrue.
    # Choosing the second bursty area. You can change to see others:
    range1=range11[1]+300 
    range2=range22[1]+300
    figPred0=plt.figure()
    plt.subplot(2,1,1)
    plt.plot(xAxis[range1:range2],arrivals[offset+range1:offset+range2],'C3-',linewidth=2,label='Arrivals')
    plt.plot(xAxis[range1:range2],traffPattern[range1:range2],'C0',\
             label='Detected Preambles')
    plt.plot(xAxis[range1:range2],exactCongArea[f'Sequence {seqForPlotting[1]}'][range1:range2]*30,'--C2',\
             linewidth=2,label='Cong. Area Label')
    plt.plot(xAxis[range1:range2],expectedBurstyAreas\
             [f'Sequence {seqForPlotting[1]}'][f'Tp={Tp}'][range1:range2]*24,\
             'C4-.',linewidth=2,label='Expected Cong. Label')
    plt.title(f'Traffic Pattern and Congested Area Labels for Tp = {Tp} [sec]')
    plt.ylabel('Detected Preambles')
    plt.xlabel('Time [sec]')
    plt.legend(loc='upper right')
    plt.grid()
    plt.subplot(2,1,2)
    plt.plot(xAxis[range1:range2],congPreambles[range1:range2],'C0',\
             label='Congested Preambles')
    plt.plot(xAxis[range1:range2],exactCongArea[f'Sequence {seqForPlotting[1]}'][range1:range2]*30,'--C2',\
             linewidth=2,label='Cong. Area Label')
    plt.plot(xAxis[range1:range2],expectedBurstyAreas\
             [f'Sequence {seqForPlotting[1]}'][f'Tp={Tp}'][range1:range2]*24,\
             'C4-.',linewidth=2,label='Expected Cong. Label')
    plt.ylabel('Congested preambles')
    plt.xlabel('Time [sec]')
    plt.legend(loc='upper right')
    figPred0.set_tight_layout('tight') # Solving overlapping labels.
    plt.grid()
    plt.show()
    #%% Plotting the results of burst detection network:
    for iTp,Tp in enumerate(TpVec):
        if iTp and input(f'\nPlot for next Tp (Tp={Tp})? (y/n) ').find('n')+1:
            break; # Stop plotting the congested area if user desires.
        predBurstSeq=burstNetOut[f'Sequence {seqForPlotting[1]}'][f'Tp={Tp}']
        figPred=plt.figure(figsize=[14,9])
        plt.subplot(2,1,1)
        plt.plot(xAxis,congPreambles,'C0',label='Congested Preambles')
        plt.plot(xAxis,exactCongArea[f'Sequence {seqForPlotting[1]}']*30,'--C2',linewidth=2,label='Exact Cong. Area')
        plt.plot(xAxis[:predBurstSeq.size],predBurstSeq*20,'C1',linewidth=2,label='Predicted Bursty Area')
        plt.title(f'Congested preambles and bursty regions for Tp = {Tp} [sec]')
        plt.ylabel('Congested preambles')
        plt.xlabel('Time [sec]')
        plt.legend(loc='upper right')
        plt.xticks(np.linspace(0,900,19))
        plt.subplot(2,1,2)
        # plt.plot(traffPattern,label='Traffic Pattern')
        plt.plot(xAxis,exactCongArea[f'Sequence {seqForPlotting[1]}']*30,'--C2',linewidth=2,label='Congested Area')
        plt.plot(xAxis[:predBurstSeq.size],predBurstSeq*25,'C1',linewidth=2,label='Predicted Bursty Area')
        plt.plot(xAxis,traffPattern,'C0',label='Traffic Pattern')
        plt.title(f'Traffic pattern and bursty regions for Tp = {Tp} [sec]')
        plt.ylabel('Detected Packets')
        plt.xlabel('Time [sec]')
        plt.legend(loc='upper right')
        plt.xticks(np.linspace(0,900,19)) # For a higher resolution axis.
        figPred.set_tight_layout('tight') # Solving overlapping labels.
        plt.show()
   
    #%% Plotting the bursty areas of the selected sequence:
    for iTp,Tp in enumerate(TpVec):
        if iTp and input(f'\nPlot for next Tp (Tp={Tp})? (y/n) ').find('n')+1:
            break; # Stop plotting the congested area if user desires.
        predBurstSeq=burstNetOut[f'Sequence {seqForPlotting[1]}'][f'Tp={Tp}']
        # criticalPoints=predBurstSeq.nonzero(as_tuple=True)[0] # Points that we expect bursty traffic.
        criticalPoints=np.nonzero(predBurstSeq)[0] # Points that we expect bursty traffic.
        range11=[criticalPoints[0]-1000] # Store the neighborhood of first point.
        range22=[criticalPoints[0]+2000] # Store the neighborhood of first point.
        for criticalPoint in criticalPoints:
            if criticalPoint>(range11[-1]+2000): # Add to the ranges only if it is a new bursty region.
                range11.append(criticalPoint-1000)
                range22.append(criticalPoint+2000)
        rows=int(np.ceil(len(range11)/2)) # Required rows to plot all of them in one figrue.
        height=rows*3 # determining the height of figrue based on the number of rows.
        figPred=plt.figure(figsize=[18,height])
        for i, (range1,range2) in enumerate(zip(range11,range22)): # Plot the extracted bursty areas:
            plt.subplot(rows,2,i+1)
            plt.plot(xAxis[range1:range2],congPreambles[range1:range2],'C0',\
                     label='Congested Preambles')
            plt.plot(xAxis[range1:range2],exactCongArea[f'Sequence {seqForPlotting[1]}'][range1:range2]*30,'--C2',\
                     linewidth=2,label='Exact Cong. Area')
            plt.plot(xAxis[:predBurstSeq.size][range1:range2],\
                     predBurstSeq[range1:range2]*20,'C1',linewidth=3,label='Predicted Bursty Area')
            plt.plot(xAxis[range1:range2],expectedBurstyAreas\
                     [f'Sequence {seqForPlotting[1]}'][f'Tp={Tp}'][range1:range2]*24,\
                     'C4-.',linewidth=2,label='Expected')
            plt.title(f'Congested preambles and bursty regions for Tp = {Tp} [sec]')
            plt.ylabel('Congested preambles')
            plt.xlabel('Time [sec]')
            plt.legend(loc='upper right')
        figPred.set_tight_layout('tight') # Solving overlapping labels.
        plt.show()
    #%% Generating/Extracting the predicted sequences using Online-Prediction and classical rolling methods:
    onlineMethodOutTraff=dict([(f'Sequence {chosenStream}',dict()) for chosenStream \
                              in seqForPlotting]) # Store the predicted results for two sequences.
    onlineMethodOutCong=dict([(f'Sequence {chosenStream}',dict()) for chosenStream \
                              in seqForPlotting]) # Store the predicted results for two sequences.
    predContainer=dict([(f'Sequence {chosenStream}',dict()) for chosenStream \
                              in seqForPlotting]) # Store the predicted results for two sequences.
    targetTraffSeq=dict([(f'Sequence {chosenStream}',[]) for chosenStream \
                              in seqForPlotting])
    targetCongSeq=dict([(f'Sequence {chosenStream}',[]) for chosenStream \
                              in seqForPlotting])
    
    bufferSizes=testResults_E.get('bufferSizes') # Load the buffer sizes
    rollingMethodOutTraff=dict([(f'bufferSize {bufferSize}',\
                                 copy.deepcopy(predContainer)) for bufferSize \
                                 in bufferSizes])
    rollingMethodOutCong=dict([(f'bufferSize {bufferSize}',\
                                 copy.deepcopy(predContainer)) for bufferSize \
                                 in bufferSizes])
        
    if not loadPlotSeq: # Run this section only if you want to generate data in this software.
        # Loading the trained RNN network and use it for both scenarios:
        rnnModel=trainedRnnNet_B.get('model') # This is the trained traffic prediction.
        rnnModelRef=copy.deepcopy(rnnModel) # The same model as above, used for classic rolling prediction model.
        seedLength=int(Tseed/frameSize/batchSize) # Seedlength in batches.
        stepLength=int(Tstep/frameSize/batchSize) # Size of each slice of fresh data
        TpMax=max(TpVec) # Maximum prediction duration.
        batchesAheadMax=int(TpMax/frameSize/batchSize) # Maximum prediction duration in batches at each step.
        batchesAhead=[int(Tp/frameSize/batchSize) for Tp in TpVec] # List of batches ahead for each Tp.
        if rnnModel.GPU_flag: # Moving the networks on the desired processing device
            device=torch.device('cuda') # Laod on GPU.
            revDev=torch.device('cpu')
        else:
            device=torch.device('cpu') # Laod on CPU.
            revDev=torch.device('cpu') # Always return on CPU!
        rnnModel.to(device) # Move the model to the desired device.
        rnnModelRef.to(device) # Move the model to the desired device.
        criterion = nn.MSELoss() # Using MSE metric to calculate the error.
        for chosenStream in seqForPlotting:
            pattern=patternArray[chosenStream,:,focusArea[0]:focusArea[1]] # The chosen sequence for comparison.
            # We make the predictions for the maximum length and then crop it for shorter predictions:
            [feedTraf,tarTraf]=preprocess(pattern[0],batchSize) # Preparing the detected traffic data
            [feedCong,tarCong]=preprocess(pattern[1],batchSize) # Preparing the congestion data
            feedData=torch.cat((feedTraf,feedCong),dim=2) # Total feed data (concatenate traffic and congestion)
            targetData=torch.cat((tarTraf,tarCong),dim=2) # Total target data
            seed=feedData[:seedLength]
            output=dict([(Tp,[]) for Tp in TpVec]) # List to store predicted bunches.
            rnnModel.init_hidden(batchSize) # Initializing the RNN network.
            rnnModel.eval() # Evaluation mode activation.
            totalNumberOfSlices=int(feedData[seedLength:].size(0)/stepLength) ################################################################
            # Generating the prediction:
            with torch.no_grad():
                outMax=rnnModel(seed.to(device),steps=batchesAheadMax, eval=True)
                for iTp,Tp in enumerate(TpVec):
                    output[Tp].append(outMax[:seedLength+batchesAhead[iTp]-1].clone())
                for i in tqdm(range(totalNumberOfSlices),colour='cyan',\
                              desc=f'Online forecasting of the sequence {chosenStream} '):
                    outMax=rnnModel(feedData[seedLength+i*stepLength:seedLength+(i+1)*stepLength].to(device),\
                                  steps=batchesAheadMax, eval=True)
                    for (Tp,BA) in zip(TpVec,batchesAhead): # cropping the desired size according to Tp
                        output[Tp].append(outMax[BA-1:BA-1+stepLength]) 
            
            for Tp in TpVec: # Error calculating
                prediction=torch.cat(output[Tp])[:targetData.size(0)].to(revDev)
                tarTensor=targetData[:prediction.size(0)]
                onlineMethodOutTraff[f'Sequence {chosenStream}']['Tp='+str(Tp)]=\
                    prediction[:,:,0].reshape(-1).numpy() # Storing the predicted sequence for MATLAB
                onlineMethodOutCong[f'Sequence {chosenStream}']['Tp='+str(Tp)]=\
                    prediction[:,:,1].reshape(-1).numpy() # Storing the predicted sequence for MATLAB           
            # Making predictions using Rolling method:
            rnnModelRef.eval() # Evaluation mode activation.
            # The input sequence to the RNN network in rolling method is sum of buffer\
            # and fresh data: inputSize = bufferSize + StepLength (here: (3*4)+4=16 batches)
            with torch.no_grad():
                # bufferSize=3*stepLength # Buffer size to store historical data in batches
                for bufferSize in bufferSizes:
                    outputRef=dict([(Tp,[]) for Tp in TpVec]) # List to store predicted bunches.
                    rnnModelRef.init_hidden(batchSize) # Initializing the RNN network.
                    outMaxRef=rnnModelRef(seed.to(device),steps=batchesAheadMax, eval=True)
                    for iTp,Tp in enumerate(TpVec):
                        outputRef[Tp].append(outMaxRef[:seedLength+batchesAhead[iTp]-1].clone())
                    for i in tqdm(range(totalNumberOfSlices),colour='yellow',\
                                  desc=f'Rolling forecasting of the sequence {chosenStream} (BS: {bufferSize})'):
                        rnnModelRef.init_hidden(batchSize) # Initializing the RNN network before feeding data.
                        outMaxRef=rnnModelRef(feedData[seedLength-bufferSize+i*stepLength:\
                                                        seedLength+(i+1)*stepLength].to(device),\
                                              steps=batchesAheadMax, eval=True)
                        for (Tp,BA) in zip(TpVec,batchesAhead): # cropping the desired size according to Tp 
                            outputRef[Tp].append(outMaxRef[BA+bufferSize-1:BA-1+bufferSize+stepLength])
                    for Tp in TpVec: # Error calculation:
                        predictionRolling=torch.cat(outputRef[Tp])[:targetData.size(0)].to(revDev)
                        tarTensor=targetData[:predictionRolling.size(0)]
                        rollingMethodOutTraff[f'bufferSize {bufferSize}'][f'Sequence {chosenStream}']['Tp='+str(Tp)]=\
                            predictionRolling[:,:,0].reshape(-1).numpy() # Storing the predicted sequence for MATLAB
                        rollingMethodOutCong[f'bufferSize {bufferSize}'][f'Sequence {chosenStream}']['Tp='+str(Tp)]=\
                            predictionRolling[:,:,1].reshape(-1).numpy() # Storing the predicted sequence for MATLAB
            targetTraffSeq[f'Sequence {chosenStream}']=tarTensor[:,:,0].reshape(-1).numpy()
            targetCongSeq[f'Sequence {chosenStream}']=tarTensor[:,:,1].reshape(-1).numpy()
    if loadPlotSeq:
        onlinePrediction=testResults_E.get('onlinePrediction')
        rollingPredinction=testResults_E.get('rollingPredinction')
        revDev=torch.device('cpu')
        for chosenStream in seqForPlotting:
            targetTraffSeq[f'Sequence {chosenStream}']=patternArray[chosenStream,0,batchSize:] # Target seq. starts after the first batch.
            targetCongSeq[f'Sequence {chosenStream}']=patternArray[chosenStream,1,batchSize:] # Target seq. starts after the first batch.
            for Tp in TpVec:
                prediction=torch.cat(onlinePrediction[f'Sequence {chosenStream}'][Tp])\
                    .to(revDev)
                onlineMethodOutTraff[f'Sequence {chosenStream}']['Tp='+str(Tp)]=\
                    prediction[:,:,0].reshape(-1).numpy() # Storing the predicted sequence for MATLAB
                onlineMethodOutCong[f'Sequence {chosenStream}']['Tp='+str(Tp)]=\
                    prediction[:,:,1].reshape(-1).numpy() # Storing the predicted sequence for MATLAB    
                for bufferSize in bufferSizes:
                    predictionRolling=torch.cat(rollingPredinction[f'bufferSize {bufferSize}']\
                                [f'Sequence {chosenStream}'][Tp]).to(revDev)
                    rollingMethodOutTraff[f'bufferSize {bufferSize}'][f'Sequence {chosenStream}']\
                        ['Tp='+str(Tp)]=predictionRolling[:,:,0].reshape(-1).numpy()
                    rollingMethodOutCong[f'bufferSize {bufferSize}'][f'Sequence {chosenStream}']\
                        ['Tp='+str(Tp)]=predictionRolling[:,:,1].reshape(-1).numpy()
                     
    #%% Plotting the predicted traffic patterns by two methods:
    # Determine the x-axis time array:
    length=len(targetTraffSeq[f'Sequence {seqForPlotting[0]}']) # Total number of samples in the sequences to be plotted.
    a=0 # Start time of simulation (actually: batchSize*frameSize)
    b=length*frameSize # Time of the last point of data.
    xAxis=np.linspace(a,b,length) # X-axis vector
    bufferSize=int(input(f'Please enter the buffer size (options: {[bs*batchSize for bs in bufferSizes]} time slots): '))//batchSize
    rollingInSize=TstepSamples+bufferSize*batchSize # Total input size of rolling method (buffered + fresh data)
    for iTp,Tp in enumerate(TpVec):
        if iTp and input(f'\nPlot for next Tp (Tp={Tp})? (y/n) ').find('n')+1:
            break; # Stop plotting the congested area if user desires.
        maximumPlotLength=min(limitPlotRange, length, len(onlineMethodOutTraff\
                                               [f'Sequence {seqForPlotting[0]}']['Tp='+str(Tp)],))
        predictedTraffic=signal.savgol_filter(\
              onlineMethodOutTraff[f'Sequence {seqForPlotting[0]}']['Tp='+str(Tp)],97,2) # Predicted traffic
        tarTraff=targetTraffSeq[f'Sequence {seqForPlotting[0]}']
        figSeq, axes= plt.subplot_mosaic('AAABB;CCCDD')
        figSeq.set_figheight(9)
        figSeq.set_figwidth(12)
        axes['A'].plot(xAxis[:maximumPlotLength],tarTraff[:maximumPlotLength],\
                 linewidth=3,label='Ground Truth')
        axes['A'].plot(xAxis[:maximumPlotLength],predictedTraffic[:maximumPlotLength],linewidth=2,\
                 label='Online Predictions')
        axes['A'].axvline(x=Tseed,ymin=0.05,ymax=0.85,color='g',lw=2,ls='--',label='Pred. Start Point')
        axes['A'].set_title(f'Predicted Traffic by Online Method for Tp = {Tp} [sec]')
        axes['A'].set_ylabel('Detecetd Packets')
        axes['A'].set_xlabel('Time [sec]')
        axes['A'].legend(loc='upper left')
        axes['A'].grid()
        axes['B'].plot(xAxis[maximumPlotLength//2:3*maximumPlotLength//4-3000],\
                       tarTraff[maximumPlotLength//2:3*maximumPlotLength//4-3000],\
                 linewidth=3,label='Ground Truth')
        axes['B'].plot(xAxis[maximumPlotLength//2:3*maximumPlotLength//4-3000],\
                       predictedTraffic[maximumPlotLength//2:3*maximumPlotLength//4-3000],linewidth=2,\
                 label='Online Predictions')
        axes['B'].set_title('Zoomed-in Plot for Online Method')
        axes['B'].set_ylabel('Detecetd Packets')
        axes['B'].set_xlabel('Time [sec]')
        axes['B'].grid()
        predictedTrafficRef=signal.savgol_filter(\
              rollingMethodOutTraff[f'bufferSize {bufferSize}'][f'Sequence {seqForPlotting[0]}']['Tp='+str(Tp)],97,2) # Predicted traffic
        axes['C'].plot(xAxis[:maximumPlotLength],tarTraff[:maximumPlotLength],\
                 linewidth=3, label='Ground Truth')
        axes['C'].plot(xAxis[:maximumPlotLength],predictedTrafficRef[:maximumPlotLength],\
                       'C3',linewidth=2, label='Rolling Predictions')
        axes['C'].axvline(x=Tseed,ymin=0.05,ymax=0.85,color='g',lw=2,ls='--',label='Pred. Start Point')
        axes['C'].set_title(f'Predicted Traffic by Rolling Method for Tp = {Tp} [sec] and Input Length of {rollingInSize} [time slots]')
        axes['C'].set_ylabel('Detecetd Packets')
        axes['C'].set_xlabel('Time [sec]')
        axes['C'].legend(loc='upper left')
        axes['C'].grid()
        axes['D'].plot(xAxis[maximumPlotLength//2:3*maximumPlotLength//4-3000],\
                       tarTraff[maximumPlotLength//2:3*maximumPlotLength//4-3000],\
                 linewidth=3, label='Ground Truth')
        axes['D'].plot(xAxis[maximumPlotLength//2:3*maximumPlotLength//4-3000],\
                       predictedTrafficRef[maximumPlotLength//2:3*maximumPlotLength//4-3000],\
                           'C3',linewidth=2, label='Rolling Predictions')
        axes['D'].set_title('Zoomed-in Plot for Rolling Method')
        axes['D'].set_ylabel('Detecetd Packets')
        axes['D'].set_xlabel('Time [sec]')
        axes['D'].grid()
        figSeq.set_tight_layout('tight') # Solving overlapping labels.
        plt.show()
    #%% Plotting the predicted Congestion patterns by two methods:
    for iTp,Tp in enumerate(TpVec):
        if iTp and input(f'\nPlot for next Tp (Tp={Tp})? (y/n) ').find('n')+1:
            break; # Stop plotting the congested area if user desires.
        maximumPlotLength=min(32000,length,len(onlineMethodOutCong\
                                               [f'Sequence {seqForPlotting[0]}']['Tp='+str(Tp)],))
        predictedCongestion=signal.savgol_filter(\
              onlineMethodOutCong[f'Sequence {seqForPlotting[0]}']['Tp='+str(Tp)],97,2) # Predicted traffic
        tarCong=targetCongSeq[f'Sequence {seqForPlotting[0]}']
        figSeq, axes= plt.subplot_mosaic('AAABB;CCCDD')
        figSeq.set_figheight(9)
        figSeq.set_figwidth(12)
        axes['A'].plot(xAxis[:maximumPlotLength],tarCong[:maximumPlotLength],\
                 linewidth=3,label='Ground Truth')
        axes['A'].plot(xAxis[:maximumPlotLength],predictedCongestion[:maximumPlotLength],linewidth=2,\
                 label='Online Predictions')
        axes['A'].axvline(x=Tseed,ymin=0.05,ymax=0.85,color='g',lw=2,ls='--',label='Pred. Start Point')
        axes['A'].set_title(f'Predicted Congestion by Online Method for Tp = {Tp} [sec]')
        axes['A'].set_ylabel('Congested Preambles')
        axes['A'].set_xlabel('Time [sec]')
        axes['A'].legend(loc='upper left')
        axes['B'].plot(xAxis[maximumPlotLength//2:3*maximumPlotLength//4-3000],\
                       tarCong[maximumPlotLength//2:3*maximumPlotLength//4-3000],\
                 linewidth=3,label='Ground Truth')
        axes['B'].plot(xAxis[maximumPlotLength//2:3*maximumPlotLength//4-3000],\
                       predictedCongestion[maximumPlotLength//2:3*maximumPlotLength//4-3000],linewidth=2,\
                 label='Online Predictions')
        axes['B'].set_title('Zoomed-in Plot for Online Method')
        axes['B'].set_ylabel('Congested Preambles')
        axes['B'].set_xlabel('Time [sec]')
        predictedCongRef=signal.savgol_filter(\
              rollingMethodOutCong[f'bufferSize {bufferSize}'][f'Sequence {seqForPlotting[0]}']['Tp='+str(Tp)],97,2) # Predicted traffic
        axes['C'].plot(xAxis[:maximumPlotLength],tarCong[:maximumPlotLength],\
                 linewidth=3, label='Ground Truth')
        axes['C'].plot(xAxis[:maximumPlotLength],predictedCongRef[:maximumPlotLength],\
                       'C3',linewidth=2, label='Rolling Predictions')
        axes['C'].axvline(x=Tseed,ymin=0.05,ymax=0.85,color='g',lw=2,ls='--',label='Pred. Start Point')
        axes['C'].set_title(f'Predicted Congestion by Rolling Method for Tp = {Tp} [sec] and Input Length of {rollingInSize}')
        axes['C'].set_ylabel('Congested Preambles')
        axes['C'].set_xlabel('Time [sec]')
        axes['C'].legend(loc='upper left')
        axes['D'].plot(xAxis[maximumPlotLength//2:3*maximumPlotLength//4-3000],\
                       tarCong[maximumPlotLength//2:3*maximumPlotLength//4-3000],\
                 linewidth=3, label='Ground Truth')
        axes['D'].plot(xAxis[maximumPlotLength//2:3*maximumPlotLength//4-3000],\
                       predictedCongRef[maximumPlotLength//2:3*maximumPlotLength//4-3000],\
                           'C3',linewidth=2, label='Rolling Predictions')
        axes['D'].set_title('Zoomed-in Plot for Rolling Method')
        axes['D'].set_ylabel('Congested Preambles')
        axes['D'].set_xlabel('Time [sec]')
        figSeq.set_tight_layout('tight') # Solving overlapping labels.
        plt.show()
        
    #%% Plotting the predicted traffic patterns by two methods on the same plot:
    # Determine the x-axis time array:
    length=len(targetTraffSeq[f'Sequence {seqForPlotting[0]}']) # Total number of samples in the sequences to be plotted.
    a=0 # Start time of simulation (actually: batchSize*frameSize)
    b=length*frameSize # Time of the last point of data.
    xAxis=np.linspace(a,b,length) # X-axis vector
    bufferSize=int(input(f'Please enter the buffer size (options: {bufferSizes}): '))
    rollingInSize=TstepSamples+bufferSize*batchSize # Total input size of rolling method (buffered + fresh data)
    for iTp,Tp in enumerate(TpVec):
        if iTp and input(f'\nPlot for next Tp (Tp={Tp})? (y/n) ').find('n')+1:
            break; # Stop plotting the congested area if user desires.
        maximumPlotLength=min(limitPlotRange, length, len(onlineMethodOutTraff\
                                               [f'Sequence {seqForPlotting[0]}']['Tp='+str(Tp)],))
        predictedTraffic=signal.savgol_filter(\
              onlineMethodOutTraff[f'Sequence {seqForPlotting[0]}']['Tp='+str(Tp)],97,2) # Predicted traffic
        predictedTrafficRef=signal.savgol_filter(\
              rollingMethodOutTraff[f'bufferSize {bufferSize}'][f'Sequence {seqForPlotting[0]}']['Tp='+str(Tp)],97,2) # Predicted traffic
        tarTraff=targetTraffSeq[f'Sequence {seqForPlotting[0]}']
        figSeq, axes= plt.subplot_mosaic('AAABB;CCCDD')
        figSeq.set_figheight(9)
        figSeq.set_figwidth(12)
        axes['A'].plot(xAxis[:maximumPlotLength],tarTraff[:maximumPlotLength],\
                 linewidth=3,label='Ground Truth')
        axes['A'].plot(xAxis[:maximumPlotLength],predictedTraffic[:maximumPlotLength],linewidth=2,\
                 label='Online Predictions')
        axes['A'].plot(xAxis[:maximumPlotLength],predictedTrafficRef[:maximumPlotLength],\
                       'C3',linewidth=2,ls='--', label='Rolling Predictions')
        axes['A'].axvline(x=Tseed,ymin=0.05,ymax=0.85,color='g',lw=2,ls='--',label='Pred. Start Point')
        axes['A'].set_title(f'Predicted Traffic for Tp = {Tp} [sec] and Input Length of {rollingInSize}')
        axes['A'].set_ylabel('Detecetd Packets')
        axes['A'].set_xlabel('Time [sec]')
        axes['A'].legend(loc='upper left')
        axes['A'].grid()
        axes['B'].plot(xAxis[maximumPlotLength//2:3*maximumPlotLength//4-3000],\
                       tarTraff[maximumPlotLength//2:3*maximumPlotLength//4-3000],\
                 linewidth=3,label='Ground Truth')
        axes['B'].plot(xAxis[maximumPlotLength//2:3*maximumPlotLength//4-3000],\
                       predictedTraffic[maximumPlotLength//2:3*maximumPlotLength//4-3000],linewidth=2,\
                 label='Online Predictions')
        axes['B'].plot(xAxis[maximumPlotLength//2:3*maximumPlotLength//4-3000],\
                       predictedTrafficRef[maximumPlotLength//2:3*maximumPlotLength//4-3000],\
                           'C3',linewidth=2,ls='--', label='Rolling Predictions')
        axes['B'].set_title('Zoomed-in Plot for Predicted Traffic')
        axes['B'].set_ylabel('Detecetd Packets')
        axes['B'].set_xlabel('Time [sec]')
        axes['B'].grid()
        #############
        predictedCongestion=signal.savgol_filter(\
              onlineMethodOutCong[f'Sequence {seqForPlotting[0]}']['Tp='+str(Tp)],97,2) # Predicted traffic
        predictedCongRef=signal.savgol_filter(\
              rollingMethodOutCong[f'bufferSize {bufferSize}'][f'Sequence {seqForPlotting[0]}']['Tp='+str(Tp)],97,2) # Predicted traffic
        tarCong=targetCongSeq[f'Sequence {seqForPlotting[0]}']
        axes['C'].plot(xAxis[:maximumPlotLength],tarCong[:maximumPlotLength],\
                 linewidth=3,label='Ground Truth')
        axes['C'].plot(xAxis[:maximumPlotLength],predictedCongestion[:maximumPlotLength],linewidth=2,\
                 label='Online Predictions')
        axes['C'].plot(xAxis[:maximumPlotLength],predictedCongRef[:maximumPlotLength],\
                       'C3',linewidth=2,ls='--', label='Rolling Predictions')
        axes['C'].axvline(x=Tseed,ymin=0.05,ymax=0.85,color='g',lw=2,ls='--',label='Pred. Start Point')
        axes['C'].set_title(f'Predicted Congestion for Tp = {Tp} [sec] and Input Length of {rollingInSize}')
        axes['C'].set_ylabel('Congested Preambles')
        axes['C'].set_xlabel('Time [sec]')
        axes['C'].legend(loc='upper left')
        axes['C'].grid()
        axes['D'].plot(xAxis[maximumPlotLength//2:3*maximumPlotLength//4-3000],\
                       tarCong[maximumPlotLength//2:3*maximumPlotLength//4-3000],\
                 linewidth=3,label='Ground Truth')
        axes['D'].plot(xAxis[maximumPlotLength//2:3*maximumPlotLength//4-3000],\
                       predictedCongestion[maximumPlotLength//2:3*maximumPlotLength//4-3000],linewidth=2,\
                 label='Online Predictions')
        axes['D'].plot(xAxis[maximumPlotLength//2:3*maximumPlotLength//4-3000],\
                       predictedCongRef[maximumPlotLength//2:3*maximumPlotLength//4-3000],\
                           'C3',linewidth=2,ls='--', label='Rolling Predictions')
        axes['D'].set_title('Zoomed-in Plot for Predicted Congested Preambles')
        axes['D'].set_ylabel('Congested Preambles')
        axes['D'].set_xlabel('Time [sec]')
        axes['D'].grid()            
            
        figSeq.set_tight_layout('tight') # Solving overlapping labels.
        plt.show()
    
    #%% Exporting the results to Matlab:
    """
    onlineMethodOutTraff  # Predicted traffic for both 117 and 301 streams using Online method.
    onlineMethodOutCong   # Predicted congestion for both 117 and 301 streams using Online method.
    rollingMethodOutTraff # Predicted traffic for both 117 and 301 streams using Rolling method.
    rollingMethodOutCong  # Predicted congestion for both 117 and 301 streams using Rolling method.
    targetTraffSeq  # Target sequence of detected preambles (Ground Truth)
    targetCongSeq   # Target sequence of congested preambles (Ground Truth)
    rnnTrainingLossHistory # Training loss (MSE) history of RNN network
    burstTrainingLoss # Training loss (MSE) history of burst detection network
    burstPredTrainingAccuracyMetrics # Accuracy metrics of training phase of burst detection network
    burstNetOut # The output of Burst detection network.
    exactCongArea # Exact congestion area
    expectedBurstyAreas # Expected burst predictions
    burstPredTestAccuracyMetrics # Accuracy metrics of TEST phase of burst detection network using FLSP
    burstPredTestAccuracyMetricsRoll # Accuracy metrics of TEST phase of burst detection network using Rolling
    """
    description_F=description_B+'\n\n'+description_C+'\n\n'+description_E # Simulation description
    data={'batchSize':batchSize,'Tstep':Tstep,'Tseed':Tseed,'TpVec':TpVec,\
          'seqForPlotting':seqForPlotting,'seqForPlotting2':seqForPlotting,'bufferSizes':bufferSizes,\
          'onlineMethodOutTraff':onlineMethodOutTraff, 'onlineMethodOutCong':onlineMethodOutCong,\
          'rollingMethodOutTraff':rollingMethodOutTraff, 'rollingMethodOutCong':rollingMethodOutCong,\
          'targetTraffSeq':targetTraffSeq, 'targetCongSeq':targetCongSeq,\
          'rnnTrainingLossHistory':rnnTrainingLossHistory, 'burstTrainingLoss':burstTrainingLoss,\
          'burstPredTrainingAccuracyMetrics':burstPredTrainingAccuracyMetrics,\
          'burstNetOut':burstNetOut, 'exactCongArea':exactCongArea,\
          'expectedBurstyAreas':expectedBurstyAreas, 'burstPredTestAccuracyMetrics':\
          burstPredTestAccuracyMetrics,'burstPredTestAccuracyMetricsRoll':\
          burstPredTestAccuracyMetricsRoll, 'description_F':description_F}
    if saveResults:
        dataManagement(data=data, save=True, fileFormat='.mat', fileName='exportToMatlab',\
                   version='_v2_1', path='F_MatlabFiles')
    else:
        print('The results are not saved!')
    
    